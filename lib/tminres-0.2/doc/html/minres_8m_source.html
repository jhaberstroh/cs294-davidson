<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>tminres: minres.m Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">tminres
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">minres.m</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="keyword">function</span> [ x, istop, itn, rnorm, Arnorm, Anorm, Acond, ynorm ] = ...
<a name="l00002"></a>00002            minres( A, b, M, shift, show, check, itnlim, rtol )
<a name="l00003"></a>00003 
<a name="l00004"></a>00004 %        [ x, istop, itn, rnorm, Arnorm, Anorm, Acond, ynorm ] = ...
<a name="l00005"></a>00005 %          minres( A, b, M, shift, show, check, itnlim, rtol )
<a name="l00006"></a>00006 %
<a name="l00007"></a>00007 % minres solves the n x n system of linear equations Ax = b
<a name="l00008"></a>00008 % or the n x n least squares problem           min ||Ax - b||_2^2,
<a name="l00009"></a>00009 % where A is a symmetric matrix (possibly indefinite or singular)
<a name="l00010"></a>00010 % and b is a given vector.  The dimension n is defined by length(b).
<a name="l00011"></a>00011 %
<a name="l00012"></a>00012 % INPUT:
<a name="l00013"></a>00013 %
<a name="l00014"></a>00014 % &quot;A&quot; may be a dense or sparse matrix (preferably sparse!)
<a name="l00015"></a>00015 % or a function handle such that y = A(x) returns the product
<a name="l00016"></a>00016 % y = A*x for any given n-vector x.
<a name="l00017"></a>00017 %
<a name="l00018"></a>00018 % If M = [], preconditioning is not used.  Otherwise,
<a name="l00019"></a>00019 % &quot;M&quot; defines a positive-definite preconditioner M = C*C&#39;.
<a name="l00020"></a>00020 % &quot;M&quot; may be a dense or sparse matrix (preferably sparse!)
<a name="l00021"></a>00021 % or a function handle such that y = M(x) solves the system
<a name="l00022"></a>00022 % My = x given any n-vector x.
<a name="l00023"></a>00023 %
<a name="l00024"></a>00024 % If shift ~= 0, minres really solves (A - shift*I)x = b
<a name="l00025"></a>00025 % (or the corresponding least-squares problem if shift is an
<a name="l00026"></a>00026 % eigenvalue of A).
<a name="l00027"></a>00027 %
<a name="l00028"></a>00028 % When M = C*C&#39; exists, minres implicitly solves the system
<a name="l00029"></a>00029 %
<a name="l00030"></a>00030 %            P(A - shift*I)P&#39;xbar = Pb,
<a name="l00031"></a>00031 %    i.e.               Abar xbar = bbar,
<a name="l00032"></a>00032 %    where                      P = inv(C),
<a name="l00033"></a>00033 %                            Abar = P(A - shift*I)P&#39;,
<a name="l00034"></a>00034 %                            bbar = Pb,
<a name="l00035"></a>00035 %
<a name="l00036"></a>00036 % and returns the solution      x = P&#39;xbar.
<a name="l00037"></a>00037 % The associated residual is rbar = bbar - Abar xbar
<a name="l00038"></a>00038 %                                 = P(b - (A - shift*I)x)
<a name="l00039"></a>00039 %                                 = Pr.
<a name="l00040"></a>00040 %
<a name="l00041"></a>00041 % OUTPUT:
<a name="l00042"></a>00042 %
<a name="l00043"></a>00043 % x      is the final estimate of the required solution
<a name="l00044"></a>00044 %        after k iterations, where k is return in itn.
<a name="l00045"></a>00045 % istop  is a value from [-1:9] to indicate the reason for termination.
<a name="l00046"></a>00046 %        The reason is summarized in msg[istop+2] below.
<a name="l00047"></a>00047 % itn    gives the final value of k (the iteration number).
<a name="l00048"></a>00048 % rnorm  estimates norm(r_k)  or norm(rbar_k) if M exists.
<a name="l00049"></a>00049 % Arnorm estimates norm(Ar_{k-1}) or norm(Abar rbar_{k-1}) if M exists.
<a name="l00050"></a>00050 %        NOTE THAT Arnorm LAGS AN ITERATION BEHIND rnorm.
<a name="l00051"></a>00051 
<a name="l00052"></a>00052 % Code authors:Michael Saunders, SOL, Stanford University
<a name="l00053"></a>00053 %              Sou Cheng Choi,  SCCM, Stanford University
<a name="l00054"></a>00054 %
<a name="l00055"></a>00055 % 02 Sep 2003: Date of Fortran 77 version, based on 
<a name="l00056"></a>00056 %              C. C. Paige and M. A. Saunders (1975),
<a name="l00057"></a>00057 %              Solution of sparse indefinite systems of linear equations,
<a name="l00058"></a>00058 %              SIAM J. Numer. Anal. 12(4), pp. 617-629.
<a name="l00059"></a>00059 %
<a name="l00060"></a>00060 % 02 Sep 2003: ||Ar|| now estimated as Arnorm.
<a name="l00061"></a>00061 % 17 Oct 2003: f77 version converted to MATLAB.
<a name="l00062"></a>00062 % 03 Apr 2005: A must be a matrix or a function handle.
<a name="l00063"></a>00063 % 10 May 2009: Parameter list shortened.
<a name="l00064"></a>00064 %              Documentation updated following suggestions from
<a name="l00065"></a>00065 %              Jeffery Kline &lt;jeffery.kline@gmail.com&gt;
<a name="l00066"></a>00066 %              (author of new Python versions of minres, symmlq, lsqr).
<a name="l00067"></a>00067 % 06 Jul 2009: Michael Chen &lt;mc462@cornell.edu&gt; reports divide by zero
<a name="l00068"></a>00068 %              when beta = 0 (in this case it was beta_2 = 0).
<a name="l00069"></a>00069 %              Realized that the istop values were out of sync.
<a name="l00070"></a>00070 %              They should be right now.
<a name="l00071"></a>00071 % 02 Sep 2011: David Fong reports error in Acond when alpha1=0.
<a name="l00072"></a>00072 %              gmax and gmin should be initialized before itn 1.
<a name="l00073"></a>00073 % 02 Sep 2011: ynorm = norm(x) is now computed directly instead of
<a name="l00074"></a>00074 %              being updated (incorrectly).
<a name="l00075"></a>00075 
<a name="l00076"></a>00076 % Known bugs:
<a name="l00077"></a>00077 %  1. As Jeff Kline pointed out, Arnorm = ||A r_{k-1}|| lags behind
<a name="l00078"></a>00078 %     rnorm = ||r_k||.  On singular systems, this means that a good
<a name="l00079"></a>00079 %     least-squares solution exists before Arnorm is small enough
<a name="l00080"></a>00080 %     to recognize it.  The solution x_{k-1} gets updated to x_k
<a name="l00081"></a>00081 %     (possibly a very large solution) before Arnorm shuts things
<a name="l00082"></a>00082 %     down the next iteration.  It would be better to keep x_{k-1}.
<a name="l00083"></a>00083 %------------------------------------------------------------------
<a name="l00084"></a>00084 
<a name="l00085"></a>00085 %  Initialize                               
<a name="l00086"></a>00086 
<a name="l00087"></a>00087 msg = [&#39; beta2 = 0.  If M = I, b and x are eigenvectors &#39;   % -1
<a name="l00088"></a>00088        &#39; beta1 = 0.  The exact solution is  x = 0       &#39;   %  0
<a name="l00089"></a>00089        &#39; A solution to Ax = b was found, given rtol     &#39;   %  1
<a name="l00090"></a>00090        &#39; A least-squares solution was found, given rtol &#39;   %  2
<a name="l00091"></a>00091        &#39; Reasonable accuracy achieved, given eps        &#39;   %  3
<a name="l00092"></a>00092        &#39; x has converged to an eigenvector              &#39;   %  4
<a name="l00093"></a>00093        &#39; acond has exceeded 0.1/eps                     &#39;   %  5
<a name="l00094"></a>00094        &#39; The iteration limit was reached                &#39;   %  6
<a name="l00095"></a>00095        &#39; A  does not define a symmetric matrix          &#39;   %  7
<a name="l00096"></a>00096        &#39; M  does not define a symmetric matrix          &#39;   %  8
<a name="l00097"></a>00097        &#39; M  does not define a pos-def preconditioner    &#39;]; %  9
<a name="l00098"></a>00098  
<a name="l00099"></a>00099 n      = length(b);
<a name="l00100"></a>00100 precon = ~isempty(M);
<a name="l00101"></a>00101 <span class="keywordflow">if</span> show
<a name="l00102"></a>00102    fprintf(<span class="stringliteral">&#39;\n minres.m   SOL, Stanford University   Version of 06 Jul 2009&#39;</span>)
<a name="l00103"></a>00103    fprintf(&#39;\n Solution of symmetric Ax = b or (A-shift*I)x = b&#39;)
<a name="l00104"></a>00104    fprintf(&#39;\n\n n      =%8g    shift =%22.14e&#39;, n,shift)
<a name="l00105"></a>00105    fprintf(&#39;\n itnlim =%8g    rtol  =%10.2e\n&#39;, itnlim,rtol)
<a name="l00106"></a>00106 end
<a name="l00107"></a>00107 
<a name="l00108"></a>00108 istop = 0;   itn   = 0;   Anorm = 0;    Acond = 0;
<a name="l00109"></a>00109 rnorm = 0;   ynorm = 0;   done  = false;
<a name="l00110"></a>00110 x     = zeros(n,1);
<a name="l00111"></a>00111 
<a name="l00112"></a>00112 %---------------------------------------------------------------------
<a name="l00113"></a>00113 % Decode A.
<a name="l00114"></a>00114 %---------------------------------------------------------------------
<a name="l00115"></a>00115 if isa(A,&#39;<span class="keywordtype">double</span>&#39;)         % A is an explicit matrix A.
<a name="l00116"></a>00116   if issparse(A)
<a name="l00117"></a>00117     nnzA = nnz(A);
<a name="l00118"></a>00118     fprintf(&#39;\n A is an explicit sparse matrix&#39;)
<a name="l00119"></a>00119     fprintf(&#39;\n nnz(A) =%8g&#39;, nnzA)
<a name="l00120"></a>00120   else
<a name="l00121"></a>00121     fprintf(&#39;\n A is an explicit dense matrix&#39; )
<a name="l00122"></a>00122   end
<a name="l00123"></a>00123 elseif isa(A,&#39;function_handle&#39;)
<a name="l00124"></a>00124   disp([&#39;The matrix A is defined by function_handle &#39; func2str(A)])
<a name="l00125"></a>00125 else
<a name="l00126"></a>00126   error(&#39;minres&#39;,&#39;A must be a matrix or a function handle&#39;)
<a name="l00127"></a>00127 end
<a name="l00128"></a>00128 
<a name="l00129"></a>00129 %---------------------------------------------------------------------
<a name="l00130"></a>00130 % Decode M.
<a name="l00131"></a>00131 %---------------------------------------------------------------------
<a name="l00132"></a>00132 if precon
<a name="l00133"></a>00133   if isa(M,&#39;<span class="keywordtype">double</span>&#39;)       % M is an explicit matrix M.
<a name="l00134"></a>00134     if issparse(M)
<a name="l00135"></a>00135       nnzM = nnz(M);
<a name="l00136"></a>00136       fprintf(&#39;\n The matrix M is an explicit sparse matrix&#39;)
<a name="l00137"></a>00137       fprintf(&#39;\n nnz(M) =%8g&#39;, nnzM)
<a name="l00138"></a>00138     else
<a name="l00139"></a>00139       fprintf(&#39;\n The matrix M is an explicit dense matrix&#39; )
<a name="l00140"></a>00140     end
<a name="l00141"></a>00141   elseif isa(M,&#39;function_handle&#39;)
<a name="l00142"></a>00142     disp([&#39;The matrix M is defined by function_handle &#39; func2str(M)])
<a name="l00143"></a>00143   else
<a name="l00144"></a>00144     error(&#39;minres&#39;,&#39;M must be a matrix or a function handle&#39;)
<a name="l00145"></a>00145   end
<a name="l00146"></a>00146 end
<a name="l00147"></a>00147 
<a name="l00148"></a>00148 %------------------------------------------------------------------
<a name="l00149"></a>00149 % Set up y and v for the first Lanczos vector v1.
<a name="l00150"></a>00150 % y  =  beta1 P&#39; v1,  where  P = C**(-1).
<a name="l00151"></a>00151 % v is really P&#39; v1.
<a name="l00152"></a>00152 %------------------------------------------------------------------
<a name="l00153"></a>00153 y     = b;
<a name="l00154"></a>00154 r1    = b;
<a name="l00155"></a>00155 if precon, y = minresxxxM( M,b ); end
<a name="l00156"></a>00156 beta1 = b&#39;*y;
<a name="l00157"></a>00157                                                 
<a name="l00158"></a>00158 %  Test for an indefinite preconditioner.
<a name="l00159"></a>00159 %  If b = 0 exactly, stop with x = 0.
<a name="l00160"></a>00160 
<a name="l00161"></a>00161 if beta1&lt; 0, istop = 9;  show = true;  done = true; end
<a name="l00162"></a>00162 if beta1==0,             show = true;  done = true; end
<a name="l00163"></a>00163 
<a name="l00164"></a>00164 if beta1&gt; 0
<a name="l00165"></a>00165   beta1  = sqrt(beta1);       % Normalize y to get v1 later.
<a name="l00166"></a>00166 
<a name="l00167"></a>00167   % See if M is symmetric.
<a name="l00168"></a>00168 
<a name="l00169"></a>00169   if check &amp; precon
<a name="l00170"></a>00170     r2     = minresxxxM( M,y );
<a name="l00171"></a>00171     s      = y&#39; *y;
<a name="l00172"></a>00172     t      = r1&#39;*r2;
<a name="l00173"></a>00173     z      = abs(s-t);
<a name="l00174"></a>00174     epsa   = (s+eps)*eps^(1/3);
<a name="l00175"></a>00175     if z &gt; epsa, istop = 8;  show = true;  done = true; end
<a name="l00176"></a>00176   end
<a name="l00177"></a>00177 
<a name="l00178"></a>00178   % See if A is symmetric.
<a name="l00179"></a>00179 
<a name="l00180"></a>00180   if check
<a name="l00181"></a>00181      w    = minresxxxA( A,y );
<a name="l00182"></a>00182      r2   = minresxxxA( A,w );
<a name="l00183"></a>00183      s    = w&#39;*w;
<a name="l00184"></a>00184      t    = y&#39;*r2;
<a name="l00185"></a>00185      z    = abs(s-t);
<a name="l00186"></a>00186      epsa = (s+eps)*eps^(1/3);
<a name="l00187"></a>00187      if z &gt; epsa, istop = 7;  done  = true;  show = true;  end
<a name="l00188"></a>00188   end
<a name="l00189"></a>00189 end
<a name="l00190"></a>00190 
<a name="l00191"></a>00191 %------------------------------------------------------------------
<a name="l00192"></a>00192 % Initialize other quantities.
<a name="l00193"></a>00193 % ------------------------------------------------------------------
<a name="l00194"></a>00194 oldb   = 0;       beta   = beta1;   dbar   = 0;       epsln  = 0;
<a name="l00195"></a>00195 qrnorm = beta1;   phibar = beta1;   rhs1   = beta1;
<a name="l00196"></a>00196 rhs2   = 0;       tnorm2 = 0;       gmax   = 0;       gmin   = realmax;
<a name="l00197"></a>00197 cs     = -1;      sn     = 0;
<a name="l00198"></a>00198 w      = zeros(n,1);
<a name="l00199"></a>00199 w2     = zeros(n,1);
<a name="l00200"></a>00200 r2     = r1;
<a name="l00201"></a>00201 
<a name="l00202"></a>00202 if show
<a name="l00203"></a>00203   fprintf(&#39;\n\n   Itn     x(1)     Compatible    LS       norm(A)  cond(A)&#39;)
<a name="l00204"></a>00204   fprintf(&#39; gbar/|A|\n&#39;)   %%%%%% Check gbar
<a name="l00205"></a>00205 end
<a name="l00206"></a>00206 
<a name="l00207"></a>00207 %---------------------------------------------------------------------
<a name="l00208"></a>00208 % Main iteration loop.
<a name="l00209"></a>00209 % --------------------------------------------------------------------
<a name="l00210"></a>00210 if ~done                              % k = itn = 1 first time through
<a name="l00211"></a>00211   while itn &lt; itnlim
<a name="l00212"></a>00212     itn    = itn+1;
<a name="l00213"></a>00213 
<a name="l00214"></a>00214     %-----------------------------------------------------------------
<a name="l00215"></a>00215     % Obtain quantities for the next Lanczos vector vk+1, k = 1, 2,...
<a name="l00216"></a>00216     % The general iteration is similar to the case k = 1 with v0 = 0:
<a name="l00217"></a>00217     %
<a name="l00218"></a>00218     %   p1      = Operator * v1  -  beta1 * v0,
<a name="l00219"></a>00219     %   alpha1  = v1&#39;p1,
<a name="l00220"></a>00220     %   q2      = p2  -  alpha1 * v1,
<a name="l00221"></a>00221     %   beta2^2 = q2&#39;q2,
<a name="l00222"></a>00222     %   v2      = (1/beta2) q2.
<a name="l00223"></a>00223     %
<a name="l00224"></a>00224     % Again, y = betak P vk,  where  P = C**(-1).
<a name="l00225"></a>00225     % .... more description needed.
<a name="l00226"></a>00226     %-----------------------------------------------------------------
<a name="l00227"></a>00227     s = 1/beta;                 % Normalize previous vector (in y).
<a name="l00228"></a>00228     v = s*y;                    % v = vk if P = I
<a name="l00229"></a>00229 
<a name="l00230"></a>00230     y = minresxxxA( A,v ) - shift*v;
<a name="l00231"></a>00231     if itn &gt;= 2, y = y - (beta/oldb)*r1; end
<a name="l00232"></a>00232 
<a name="l00233"></a>00233     alfa   = v&#39;*y;              % alphak
<a name="l00234"></a>00234     y      = (- alfa/beta)*r2 + y;
<a name="l00235"></a>00235     r1     = r2;
<a name="l00236"></a>00236     r2     = y;
<a name="l00237"></a>00237     if precon,  y = minresxxxM( M,r2 );  end
<a name="l00238"></a>00238     oldb   = beta;              % oldb = betak
<a name="l00239"></a>00239     beta   = r2&#39;*y;             % beta = betak+1^2
<a name="l00240"></a>00240     if beta &lt; 0, istop = 9;  break;  end
<a name="l00241"></a>00241     beta   = sqrt(beta);
<a name="l00242"></a>00242     tnorm2 = tnorm2 + alfa^2 + oldb^2 + beta^2;
<a name="l00243"></a>00243 
<a name="l00244"></a>00244     if itn==1                   % Initialize a few things.
<a name="l00245"></a>00245       if beta/beta1 &lt;= 10*eps   % beta2 = 0 or ~ 0.
<a name="l00246"></a>00246         istop = -1;             % Terminate later.
<a name="l00247"></a>00247       end
<a name="l00248"></a>00248     end
<a name="l00249"></a>00249 
<a name="l00250"></a>00250     % Apply previous rotation Qk-1 to get
<a name="l00251"></a>00251     %   [deltak epslnk+1] = [cs  sn][dbark    0   ]
<a name="l00252"></a>00252     %   [gbar k dbar k+1]   [sn -cs][alfak betak+1].
<a name="l00253"></a>00253 
<a name="l00254"></a>00254     oldeps = epsln;
<a name="l00255"></a>00255     delta  = cs*dbar + sn*alfa; % delta1 = 0         deltak
<a name="l00256"></a>00256     gbar   = sn*dbar - cs*alfa; % gbar 1 = alfa1     gbar k
<a name="l00257"></a>00257     epsln  =           sn*beta; % epsln2 = 0         epslnk+1
<a name="l00258"></a>00258     dbar   =         - cs*beta; % dbar 2 = beta2     dbar k+1
<a name="l00259"></a>00259     root   = norm([gbar dbar]);
<a name="l00260"></a>00260     Arnorm = phibar*root;       % ||Ar{k-1}||
<a name="l00261"></a>00261 
<a name="l00262"></a>00262     % Compute the next plane rotation Qk
<a name="l00263"></a>00263 
<a name="l00264"></a>00264     gamma  = norm([gbar beta]); % gammak
<a name="l00265"></a>00265     gamma  = max([gamma eps]);
<a name="l00266"></a>00266     cs     = gbar/gamma;        % ck
<a name="l00267"></a>00267     sn     = beta/gamma;        % sk
<a name="l00268"></a>00268     phi    = cs*phibar ;        % phik
<a name="l00269"></a>00269     phibar = sn*phibar ;        % phibark+1
<a name="l00270"></a>00270 
<a name="l00271"></a>00271     % Update  x.
<a name="l00272"></a>00272 
<a name="l00273"></a>00273     denom = 1/gamma;
<a name="l00274"></a>00274     w1    = w2;
<a name="l00275"></a>00275     w2    = w;
<a name="l00276"></a>00276     w     = (v - oldeps*w1 - delta*w2)*denom;
<a name="l00277"></a>00277     x     = x + phi*w;
<a name="l00278"></a>00278 
<a name="l00279"></a>00279     % Go round again.
<a name="l00280"></a>00280 
<a name="l00281"></a>00281     gmax   = max([gmax gamma]);
<a name="l00282"></a>00282     gmin   = min([gmin gamma]);
<a name="l00283"></a>00283     z      = rhs1/gamma;
<a name="l00284"></a>00284     rhs1   = rhs2 - delta*z;
<a name="l00285"></a>00285     rhs2   =      - epsln*z;
<a name="l00286"></a>00286 
<a name="l00287"></a>00287     % Estimate various norms.
<a name="l00288"></a>00288 
<a name="l00289"></a>00289     Anorm  = sqrt( tnorm2 );
<a name="l00290"></a>00290     ynorm  = norm(x);
<a name="l00291"></a>00291     epsa   = Anorm*eps;
<a name="l00292"></a>00292     epsx   = Anorm*ynorm*eps;
<a name="l00293"></a>00293     epsr   = Anorm*ynorm*rtol;
<a name="l00294"></a>00294     diag   = gbar;
<a name="l00295"></a>00295     <span class="keywordflow">if</span> diag==0, diag = epsa; end
<a name="l00296"></a>00296 
<a name="l00297"></a>00297     qrnorm = phibar;
<a name="l00298"></a>00298     rnorm  = qrnorm;
<a name="l00299"></a>00299     test1  = rnorm/(Anorm*ynorm);    %  ||r|| / (||A|| ||x||)
<a name="l00300"></a>00300     test2  = root / Anorm;      % ||Ar{k-1}|| / (||A|| ||r_{k-1}||)
<a name="l00301"></a>00301 
<a name="l00302"></a>00302     % Estimate  cond(A).
<a name="l00303"></a>00303     % In this version we look at the diagonals of  R  in the
<a name="l00304"></a>00304     % factorization of the lower Hessenberg matrix,  Q * H = R,
<a name="l00305"></a>00305     % where H is the tridiagonal matrix from Lanczos with one
<a name="l00306"></a>00306     % extra row, beta(k+1) e_k^T.
<a name="l00307"></a>00307 
<a name="l00308"></a>00308     Acond  = gmax/gmin;
<a name="l00309"></a>00309 
<a name="l00310"></a>00310     % See <span class="keywordflow">if</span> any of the stopping criteria are satisfied.
<a name="l00311"></a>00311     % In rare cases, istop is already -1 from above (Abar = const*I).
<a name="l00312"></a>00312 
<a name="l00313"></a>00313     if istop==0
<a name="l00314"></a>00314       t1 = 1 + test1;      % These tests work <span class="keywordflow">if</span> rtol &lt; eps
<a name="l00315"></a>00315       t2 = 1 + test2;
<a name="l00316"></a>00316       <span class="keywordflow">if</span> t2    &lt;= 1      , istop = 2; end
<a name="l00317"></a>00317       <span class="keywordflow">if</span> t1    &lt;= 1      , istop = 1; end
<a name="l00318"></a>00318       
<a name="l00319"></a>00319       <span class="keywordflow">if</span> itn   &gt;= itnlim , istop = 6; end
<a name="l00320"></a>00320       <span class="keywordflow">if</span> Acond &gt;= 0.1/eps, istop = 4; end
<a name="l00321"></a>00321       <span class="keywordflow">if</span> epsx  &gt;= beta1  , istop = 3; end
<a name="l00322"></a>00322      %<span class="keywordflow">if</span> rnorm &lt;= epsx   , istop = 2; end
<a name="l00323"></a>00323      %<span class="keywordflow">if</span> rnorm &lt;= epsr   , istop = 1; end
<a name="l00324"></a>00324       <span class="keywordflow">if</span> test2 &lt;= rtol   , istop = 2; end
<a name="l00325"></a>00325       <span class="keywordflow">if</span> test1 &lt;= rtol   , istop = 1; end
<a name="l00326"></a>00326     end
<a name="l00327"></a>00327 
<a name="l00328"></a>00328     % See <span class="keywordflow">if</span> it is time to print something.
<a name="l00329"></a>00329 
<a name="l00330"></a>00330     prnt   = <span class="keyword">false</span>;
<a name="l00331"></a>00331     <span class="keywordflow">if</span> n      &lt;= 40       , prnt = <span class="keyword">true</span>; end
<a name="l00332"></a>00332     <span class="keywordflow">if</span> itn    &lt;= 10       , prnt = <span class="keyword">true</span>; end
<a name="l00333"></a>00333     <span class="keywordflow">if</span> itn    &gt;= itnlim-10, prnt = true; end
<a name="l00334"></a>00334     <span class="keywordflow">if</span> mod(itn,10)==0     , prnt = <span class="keyword">true</span>; end
<a name="l00335"></a>00335     <span class="keywordflow">if</span> qrnorm &lt;= 10*epsx  , prnt = <span class="keyword">true</span>; end
<a name="l00336"></a>00336     <span class="keywordflow">if</span> qrnorm &lt;= 10*epsr  , prnt = <span class="keyword">true</span>; end
<a name="l00337"></a>00337     <span class="keywordflow">if</span> Acond  &lt;= 1e-2/eps , prnt = true; end
<a name="l00338"></a>00338     <span class="keywordflow">if</span> istop  ~=  0       , prnt = <span class="keyword">true</span>; end
<a name="l00339"></a>00339 
<a name="l00340"></a>00340     <span class="keywordflow">if</span> show &amp; prnt
<a name="l00341"></a>00341       <span class="keywordflow">if</span> mod(itn,10)==0, disp(<span class="charliteral">&#39; &#39;</span>); end
<a name="l00342"></a>00342       str1 = sprintf(<span class="stringliteral">&#39;%6g %12.5e %10.3e&#39;</span>, itn,x(1),test1);
<a name="l00343"></a>00343       str2 = sprintf(<span class="stringliteral">&#39; %10.3e&#39;</span>,           test2);
<a name="l00344"></a>00344       str3 = sprintf(<span class="stringliteral">&#39; %8.1e %8.1e&#39;</span>,      Anorm,Acond);
<a name="l00345"></a>00345       str4 = sprintf(<span class="stringliteral">&#39; %8.1e&#39;</span>,            gbar/Anorm);
<a name="l00346"></a>00346       str  = [str1 str2 str3 str4];
<a name="l00347"></a>00347       fprintf(<span class="stringliteral">&#39;\n %s&#39;</span>, str)
<a name="l00348"></a>00348 
<a name="l00349"></a>00349       debug = false;  % true;
<a name="l00350"></a>00350       if debug   % Print true Arnorm.
<a name="l00351"></a>00351                  % This works only if no preconditioning.
<a name="l00352"></a>00352         vv = b - minresxxxA(A,x)  + shift*x;    % vv = b - (A - shift*I)*x
<a name="l00353"></a>00353         ww =     minresxxxA(A,vv) - shift*vv;   % ww = (A - shift*I)*vv = &quot;Ar&quot;
<a name="l00354"></a>00354         trueArnorm = norm(ww);
<a name="l00355"></a>00355         fprintf(&#39;\n Arnorm = %12.4e   True ||Ar|| = %12.4e&#39;, Arnorm,trueArnorm)
<a name="l00356"></a>00356       end
<a name="l00357"></a>00357     end % show &amp; prnt
<a name="l00358"></a>00358 
<a name="l00359"></a>00359     if istop ~= 0, break; end
<a name="l00360"></a>00360 
<a name="l00361"></a>00361   end % main loop
<a name="l00362"></a>00362 end % if ~done early
<a name="l00363"></a>00363 
<a name="l00364"></a>00364 % Display final status.
<a name="l00365"></a>00365 
<a name="l00366"></a>00366 if show
<a name="l00367"></a>00367   fprintf(&#39;\n\n istop   =%3g               itn   =%6g&#39;, istop,itn  )
<a name="l00368"></a>00368   fprintf(&#39;\n Anorm   =%12.4e      Acond =%12.4e&#39;, Anorm,Acond)
<a name="l00369"></a>00369   fprintf(&#39;\n rnorm   =%12.4e      ynorm =%12.4e&#39;, rnorm,ynorm)
<a name="l00370"></a>00370   fprintf(&#39;\n Arnorm  =%12.4e\n&#39;, Arnorm)
<a name="l00371"></a>00371   disp(msg(istop+2,:))
<a name="l00372"></a>00372 end
<a name="l00373"></a>00373 %-----------------------------------------------------------------------
<a name="l00374"></a>00374 % End function pdco.m
<a name="l00375"></a>00375 %-----------------------------------------------------------------------
<a name="l00376"></a>00376 
<a name="l00377"></a>00377 
<a name="l00378"></a>00378 function y = minresxxxA( A,x )
<a name="l00379"></a>00379 
<a name="l00380"></a>00380 % sets   y = A*x for a matrix A defined by input parameter A.
<a name="l00381"></a>00381 %
<a name="l00382"></a>00382 % 10 May 2009: A is now a matrix or a function handle.
<a name="l00383"></a>00383 
<a name="l00384"></a>00384   if isa(A,&#39;<span class="keywordtype">double</span>&#39;)
<a name="l00385"></a>00385     y = A*x;
<a name="l00386"></a>00386   else
<a name="l00387"></a>00387     y = A(x);
<a name="l00388"></a>00388   end
<a name="l00389"></a>00389 %-----------------------------------------------------------------------
<a name="l00390"></a>00390 % End private function minresxxxA
<a name="l00391"></a>00391 %-----------------------------------------------------------------------
<a name="l00392"></a>00392 
<a name="l00393"></a>00393 
<a name="l00394"></a>00394 function y = minresxxxM( M,x )
<a name="l00395"></a>00395 
<a name="l00396"></a>00396 % solves My = x, where M is the preconditioner.
<a name="l00397"></a>00397 %
<a name="l00398"></a>00398 % 10 May 2009: M is now a matrix or a function handle.
<a name="l00399"></a>00399 
<a name="l00400"></a>00400   if isa(M,&#39;<span class="keywordtype">double</span>&#39;)
<a name="l00401"></a>00401     y = M\x;
<a name="l00402"></a>00402   else
<a name="l00403"></a>00403     y = M(x);
<a name="l00404"></a>00404   end
<a name="l00405"></a>00405 %-----------------------------------------------------------------------
<a name="l00406"></a>00406 % End private function minresxxxM
<a name="l00407"></a>00407 %-----------------------------------------------------------------------
<a name="l00408"></a>00408 
</pre></div></div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Mon Apr 16 2012 11:57:02 for tminres by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
